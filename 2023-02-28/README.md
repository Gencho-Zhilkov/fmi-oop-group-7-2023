# Упражнение 2


### Свойства, Състояние и Способности

Една от основните цели на ООП е да ни позволи по-лесно да моделираме обектите от реалния свят и взаимодействията между тях. На глобално ниво, един обект се определя от следните три неща:

1. Неговите _**свойства**_ или _характеристики_: В ООП свойствана на обектите се описват посредством _**полетата**_ (член-променливи/член-данни/атрибути) на сътветсващия клас. Имената на тези полета обикновено са _**съществителни**_.

2. Неговото текущо _**състояние**_: то се определя от текущите _**стойности**_ на полетата на обекта. Тези стойности могат - и често го правят - да модифицират поведението на дадения обект.

3. Неговите _**способности**_ или _поведение_: Това са _действията_, който може да извършва дадения обект. В ООП тези действия се представят чрез _**методите**_ (член-функциите) на класа. Имената на методите обикновено са _**глаголи**_.

_**Примери**_:

1. **Рационални числа**:  Едно рационално число се _характеризира_ от неговите числител и знаменател. _Състоянието_ му се определя изцяло само от техните стойности. В C++ това се представя посредством две полета (член променливи) `numerator` и `denominator`:
```cpp
  int numerator;
  int denominator;
```
_Действията_, който могат да се извършват с рационални числа като _събиране_ например, се представят посредством методите на класа `Rational`:
```cpp
  Rational add(const Rational& r) const {
    return Rational{
      numerator * r.denominator + r.numerator * denominator,
      denominator * r.denominator
    };
  }
```

2. **Файлове**: За операционната система например, един файл се характеризира от се неговото име (`name`), разширение (`.cpp`, `.pdf`, `.exe`, ...), къде се намира във файловата система (`path`), кой има право да го чете или да пише по него (`permissions`), дали в момента е отворен (се използва от някоя програма), и т.н...
_Действията_, който операционната система ни позволява да вършим са: да създаваме, местим и преименуваме файлове, както и да четем _от_ и пишем _във_ тях - стига да имаме необходимите _права_ (`permisssions`) за това.

_**N.B.**_ Често различните програми моделират един и същ обект по различни начини, тъй като имат различни _**нужди**_: _Cъдържанието_ на един файл, например, няма особено голямо значение за операционната система и тя го моделира като масив или от байтове (_бинарни файлове_) или от линии текст (_текстови файлове_). Същевременно, съдържанието на един _**cpp**_ файл има _огромно_ значение за вашия С++ компилатор или едитор, както често и за вас самите - оценка, работа, заплата... - много повече, отколкото броя байтове или линии в него.


### Интерфейс и Имплементация:

_**Интерфейсът**_ на един клас или метод отговаря на въпросите **_"Какво прави този клас/метод и как се ползва?"_**

_**Имплементацията**_ отговаря на въпроса: **_"Как го прави?"_**

_**Примери**_:

1. Събиране на целочислени (`int`) стойности в C++:
  - _Интерфейс_: За да съберем две стойности `x` и `y`, пишем `x + y`. Резултатът от операцията е сборa на `x` и `y` (модуло $2^{32}$ за 32-битов `int`).
  - _Имплементация_: C++ кодът се компилира до асемблер, който се транслира до машинни инструкции, който се изпълняват от процесора. Процесорът е изграден от милиарди на брои транзистори и жици. Механизмът на работа на един транзистор се обяснява от законите на квантовата механика...

2. Педали за газ и спирачка:
  - _Интерфейс_: Педалът на газта кара автомобила да се движи по-бързо. Педалът на спирачката го забавя. Колкото по-силно натиснете педала на газта/спирачката, толкова по-рязко колата ускорява/спира.
  - _Имплементация_: Нямам представа. Най-вероятно има разлики между различните автомобили. Питайте някой автомобилен техник или инженер...

Както може да се досетите от примерите основната _цел_ на разделянето на _интерфейс_ и _имплементация_ е, че това ни позволява да боравим с дадени обекти - напр. да пишем код или да караме кола - _**без**_ да има нужда да знаем всеки имплементационен детайл, стига да сме наясно с техните интерфейси (т.е. да знаем кое какво прави).

_**N.B.**_ В ООП дизайнът - особено на публичния (`public`) интерфейс - е много по-важен от - особено първоначалната - имлементация. _**Защо?**_


### Синтаксис:

1. **Конструктори**: За момента е важно да знаете следните неща:
  - Конструкторите са _специални_ методи на даден клас/тип, които се извикват _автоматично_, когато създаваме нови обекти/инстанции от този клас.
  - Конструкторте винаги се казват по същия начин като класа.
  - Както може да дефинирате повече от една функция с едно и също име (_function overloading_), така може да дефинирате и много на брой конструктори, всеки от които приема различни по брой или вид аргументи.
  - Има три на брой _"специални"_ конструктора: _default_, _copy_ и _move_, които се генерират от компилатора _по подразбиране_. (За тях ще говорим по-подробно, когато ги минете на лекции).

_**Пример**_:
```cpp
  Rational(const int num=0, const int denom=1) {
    numerator = num;
    denominator = denom;

    if (denominator == 0) {
      throw std::invalid_argument("Denominator cannot be 0!");
    } else if (denominator < 0) {
      // Sign information is carried by the numerator,
      // so switch the signs of both `numerator` and `denominator`.
      numerator *= -1;
      denominator *= -1;
    }
  }
```

2. **Методи**: изглеждат по същия начин като функциите, но имат един допълнителен скрит (_имплицитен_) аргумент: `this`, който е указател (pointer) към настоящия обект. Например:
```cpp
  Rational mutiply(const Rational& r) const {
    return Rational{
      numerator * r.numerator,
      denominator * r.denominator
    };
  }
```
е същото като:
```cpp
  Rational mutiply(const Rational& r) const {
    return Rational{
      this->numerator * r.numerator,
      this->denominator * r.denominator
    };
  }
```
И когато го извикаме с `r1.mutiply(r2)`, `this` сочи към адреса на `r1`, а `r` e референция към `r2`. (В _УП_ `multiply` щеше да бъде фунцкия с два параметъра, съответно `this` и `r`.)


### Читанка:
  - [Doing well in your courses](https://cs.stanford.edu/people/karpathy/advice.html): полезни съвети от [Андрей Карпати](https://karpathy.ai/) (доскоро шеф на _Computer Vision_ отдела на _Tesla_) за това как да учите по-ефективно.


### Първи стъпки в ООП 2:

1. _Size matters_: Нека е дадена следната структура:
```cpp
struct S {
    char    ch;
    long    l;
    short   sh1[3];
    char    str1[2];
    double  dbl[2];
    short   sh2[1];
    float   f[3];
    char    str2[3];
};
```

Отговорете въпросите [тук](https://forms.gle/YhtbBSNRRuofFakX6). За целта може да използвате файла `size_matters.cpp`, като добавите в `main` подходящи извиквания на функциите [`sizeof`](https://en.cppreference.com/w/cpp/language/sizeof) и [`offsetof`](https://en.cppreference.com/w/cpp/types/offsetof).

_**Бонус**_: Какво ще се промени в отговорите на предните въпроси ако заменим `struct` с `class`?


2. Рационални числа: Дефинирайте клас `Rational`, който енкапсулира концепцията за рационално число, като за целта имплементирате следните _**методи**_:
  - конструктор, който приема две цели числа - съответно за числител и знаменател.
  - `add`, който събира настоящото число (`this`) с друго рационално.
  - `sub`, който вади от настоящото число друго рационално.
  - `multiply`, който умножава настоящото число по друго рационално.
  - `divide`, който дели настоящото число на друго рационално.
  - `print`, който отпечатва числото на `std::cout`.

_**Бонус**_:
  - "празен" default (т.е. без аргументи) конструктор.
  - _copy constructor_ и _assignment operator_.
  - `operator <<`, който отпечатва едно число на изходен поток (`std::ostream`).


3. Комплексни числа: Дефинирайте клас `Complex`, който енкапсулира концепцията за комплексно число, като за целта имплементирате следните _**методи**_:
  - конструктор, който приема две цели числа, съответстващи на реалната и имагинерната части на числото.
  - `add`, който събира настоящото число (`this`) с друго комплексно число.
  - `sub`, който вади от настоящото число друго комплексно число.
  - `multiply`, който умножава настоящото число по друго комплексно число.
  - `divide`, който дели настоящото число на друго комплексно число.
  - `nеgate`, коята връща противоположното на даденото число.
  - `conjugate`, която връща комплексното спрегнато на даденото число

_**Бонус**_:
  - _copy constructor_ и _assignment operator_: може да използвате `default`.
  - `operator <<`, който отпечатва едно число на изходен поток (`std::ostream`).

Какви други операции (_методи_ или _функции_) върху комплексни числа смятате, че биха били полезни? Разгледайте имплементацията на комплексни числа ([`std::complex`](https://en.cppreference.com/w/cpp/numeric/complex)) в стандартната библиотека. Кои операции са дефинирани там? Какво друго ви прави впечатление?


4. [Домашно] Дефинирайте тип (`class` или `struct`) `Clock` (часовник), който да енкапсулира концепцията за време от денонощието (часове, минути, секунди). За целта първо отговорете на следните въпроси:
  - Какви полета (член-променливи) ни трябват? Каква е тяхната _"видимост"_: `public` или `private`?
  - Какви конструктори искаме да има? Има ли смисъл от _default_ (без аргументи) конструктор? Ако да, на кой час съответства той?
  - Какви методи трябва да имплементирате? За да отговорите на този въпрос, помислете за това как бихте ползвали един часовник: Kакви действия бихте искали да можете да извършвате със или върху него? На какви въпроси бихте искали да може да отговяра.

  _**Пример**_: Ако сега е `14:15:35`, то искам да мога да знам _колко ще бъде часа_ след 5 сек; след 20 мин; след 3 часа и половина. Следователно, имам нужда от метод(и) `add`, които да връща колко ще бъде часа след определен интервал (час:мин:сек) от време.
