# Упражнение 4


### Move semantics

### Предефиниране на оператори (`operator` _overloading_):


### Читанка:
  - [Bjarne Stroustrup's FAQ](https://www.stroustrup.com/bs_faq.html) отговори на _"често задавани въпроси"_ от [Bjarne Stroustrup](https://www.stroustrup.com/index.html), създателят на C++, както и едно [кратко интервю](https://www.codecademy.com/resources/blog/bjarne-stroustrup-interview/) с него.


### Задачи:

1. Задачка закачка: Разгледайте класовете `Dummy` и `Dummy2` дефинирани във файла `dummies.cpp`. След това изпълнете всяко от дадените по-долу парчета код. Какво очаквата да се отпечата? Съответства ли резултата не вашите очаквания?

```cpp
    Dummy d1{};
    {
        Dummy d2 = {7};
        d1 = d2;
        d2.doSomething();
    }
    d1.doSomething();
```

```cpp
    Dummy *dummies = new Dummy[5]{3, 7, 5};
    dummies[0].doSomething();
    dummies[4].doSomething();
    delete[] dummies;
```

```cpp
    Dummy2 dd{};
```

```cpp
    Dummy2 dd;
    Dummy2 dd2{dd};
```

```cpp
    Dummy2 dd{5, 7};
```

- Променете конструктора на класа `Dummies`, така че да извиква само конструкторите на своите член данни (а **НЕ** първо конструктора по подразбиране, след което оператора за присвояване).

- Отпечатайте размера на `Dummy` и на `Dummies`? Колко получихте? Колко очаквахте да получите? Защо?


2. [Динамичен масив](https://en.wikipedia.org/wiki/Dynamic_array): целта на упражнението е да създадем масив с променлива дължина, която нараства _автоматично_, когато добавяме нови елементи в него (сходно с класа [`std::vector`](https://en.cppreference.com/w/cpp/container/vector)). За момента ще се ограничим до масив, които е само от цели числа (`int`). По нататък (когато говорим за _шаблони_ или _templates_), ще видим как можем да премахнем това ограничение!

За целта мплементирайте следните методи:
  - Конструктор по подразбиране, който създава празен масив.
  - Copy constructor и Assignment operator.
  - Move constructor и Move assignment operator.
  - Destructor, който освобождава динамичната памет!

  _**Въпрос**_: Можете ли да използвате генерираните от компилатора?

  - `append(value)`, който добавя стойността `value` накрая на масива.
  - `insert(pos, value)`, който вмъква стойността `value` на позиция `pos`.

  _**Въпрос**_: Какво трябва да се случи ако `pos` е след _края_ на масива?

  - `pop()`, който премахва стойността, която е на последна позиция в масива.

  _**Въпрос**_: Какво трябва да се случи, когато масивът е празен?

  - `remove(pos)`, който премахва стойността, която се намира на позиция `pos`.

  _**Въпрос**_: Какво трябва да се случи ако `pos` е след _края_ на масива?

  - `clear()`, който премахва всички елементи от масива.
  - `isEmpty()`, който връща дали масивът е празен или съдържа елементи.
  - `size()`, който връща броя на елементите в масива.
  - `get(pos)`, който връща числото, което се намира на позиция `pos`.
  - `set(pos, value)`, който записва стойността `value` на позиция `pos`.
  - `find(value)`, който връща позицията на стойността `value`.

_**Въпроси**_:
  - Кои са _граничните случай_, които трябва да разгледате за последните три метода?
  - Кои методи трябва да бъдат `const`?
  - **[Бонус]**: сравнете нашата имплементация на динамичен масив, с тази на `std::vector`. Какви разлики откривате?


3. **Предефиниране на оператори**: Нека се върнем към класа `Rational`, който дефинирахме преди две седмици. Целта е да го направим по-интуитивен за използване, като заменим методите `add`, `sub`, `multiply`, `divide` със съответстващите им аритметични оператори `+`, `-`, `*`, `/`. Също така искаме да позволим на нашите клиенти да сравняват две рационални числа, за което е нужно да предефинириме операторите за сравнение: `==`, `!=`, `<`, `<=`, `>=`, `>`.

_**Въпрос**_: От кои други оператори смятате, че има нужда? Защо?

_**N.B.**_ **НЕ** е нужно да започвате отначало класа за рационално число. Може да използвате вашето решение или файла `rational.cpp`.
