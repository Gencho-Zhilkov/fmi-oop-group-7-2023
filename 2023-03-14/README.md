# Упражнение 4


### Move семантика:
Нека имаме класа `IntVector`, който дефинирахме по време на последното упражнение:
```cpp
class IntVector {
private:
    size_t capacity;
    size_t count;
    int *array;

public:
    //...
};
```

Разгледайте внимателно следната функция. Виждате ли някакъв проблем в нея?
```cpp
IntVector doubleValues(const IntVector& v) {
    IntVector res{};
    for(size_t i = 0; i < v.size(); i++) {
        res.append(2 * v.get(i));
    }
    return res;
}
```

По какъв начин move конструктора ви помага да решите проблема?


### Предефиниране на оператори (`operator` _overloading_):

Да разгледаме класа `Complex`, който дефинирахме като:
```cpp

class Complex {
private:
    double real;
    double imag;

public:
    // ...

    Complex add(const Complex& c) const {
        return Complex{real + c.real, imag + c.imag};
    }
};
```

В един идеален свят, бихме искали събирането на две комплексни (`Complex`) числа да изглежда по същия начин, по който изглежда и събирането на две цели (`int`, `long`) или на две числа с плаваща запетая (`float`, `double`)!

_Решение_: предефинираме оператора `+`, така че да работи с комплексни числа!

```cpp

class Complex {
private:
    double real;
    double imag;

public:
    // ...

    // Вътре в класа:
    Complex operator +(const Complex& c) const {
        return Complex{real + c.real, imag + c.imag};
    }

    // Или извън класа:
    friend Complex operator +(const double r, const Complex& c);
};

Complex operator +(const double r, const Complex& c) {
    return Complex{real + c.real, c.imag};
}
```


### Читанка:
  - [Bjarne Stroustrup's FAQ](https://www.stroustrup.com/bs_faq.html) отговори на _"често задавани въпроси"_ от [Bjarne Stroustrup](https://www.stroustrup.com/index.html), създателят на C++, както и едно [кратко интервю](https://www.codecademy.com/resources/blog/bjarne-stroustrup-interview/) с него.


### Задачи:

1. Задачка закачка: Разгледайте класовете `Dummy` и `Dummy2` дефинирани във файла `dummies.cpp`. След това изпълнете всяко от дадените по-долу парчета код. Какво очаквата да се отпечата? Съответства ли резултата не вашите очаквания?

```cpp
    Dummy d1{};
    {
        Dummy d2 = {7};
        d1 = d2;
        d2.doSomething();
    }
    d1.doSomething();
```

```cpp
    Dummy *dummies = new Dummy[5]{3, 7, 5};
    dummies[0].doSomething();
    dummies[4].doSomething();
    delete[] dummies;
```

```cpp
    Dummy2 dd{};
```

```cpp
    Dummy2 dd;
    Dummy2 dd2{dd};
```

```cpp
    Dummy2 dd{5, 7};
```

- Променете конструктора на класа `Dummy2`, така че да извиква само конструкторите на своите член данни (а **НЕ** първо конструктора по подразбиране, след което оператора за присвояване).

- Отпечатайте размера на `Dummy` и на `Dummy2`? Колко получихте? Колко очаквахте да получите? Защо?


2. [Динамичен масив](https://en.wikipedia.org/wiki/Dynamic_array): целта на упражнението е да създадем масив с променлива дължина, която нараства _автоматично_, когато добавяме нови елементи в него (сходно с класа [`std::vector`](https://en.cppreference.com/w/cpp/container/vector)). За момента ще се ограничим до масив, които е само от цели числа (`int`). По нататък (когато говорим за _шаблони_ или _templates_), ще видим как можем да премахнем това ограничение!

За целта мплементирайте следните методи:
  - Конструктор по подразбиране, който създава празен масив.
  - Copy constructor и Assignment operator.
  - Move constructor и Move assignment operator.
  - Destructor, който освобождава динамичната памет!

  _**Въпрос**_: Можете ли да използвате генерираните от компилатора?

  - `append(value)`, който добавя стойността `value` накрая на масива.
  - `insert(pos, value)`, който вмъква стойността `value` на позиция `pos`.

  _**Въпрос**_: Какво трябва да се случи ако `pos` е след _края_ на масива?

  - `pop()`, който премахва стойността, която е на последна позиция в масива.

  _**Въпрос**_: Какво трябва да се случи, когато масивът е празен?

  - `remove(pos)`, който премахва стойността, която се намира на позиция `pos`.

  _**Въпрос**_: Какво трябва да се случи ако `pos` е след _края_ на масива?

  - `clear()`, който премахва всички елементи от масива.
  - `isEmpty()`, който връща дали масивът е празен или съдържа елементи.
  - `size()`, който връща броя на елементите в масива.
  - `get(pos)`, който връща числото, което се намира на позиция `pos`.
  - `set(pos, value)`, който записва стойността `value` на позиция `pos`.
  - `find(value)`, който връща позицията на стойността `value`.

_**Въпроси**_:
  - Кои са _граничните случай_, които трябва да разгледате за последните три метода?
  - Кои методи трябва да бъдат `const`?
  - **[Бонус]**: сравнете нашата имплементация на динамичен масив, с тази на `std::vector`. Какви разлики откривате?


3. **Предефиниране на оператори**: Нека се върнем към класа `Rational`, който дефинирахме преди две седмици. Целта е да го направим по-интуитивен за използване, като заменим методите `add`, `sub`, `multiply`, `divide` със съответстващите им аритметични оператори `+`, `-`, `*`, `/`. Също така искаме да позволим на нашите клиенти да сравняват две рационални числа, за което е нужно да предефинириме операторите за сравнение: `==`, `!=`; и наредба: `<`, `<=`, `>=`, `>`.

_**Въпрос**_: От кои други оператори смятате, че има нужда? Защо?

_**N.B.**_ **НЕ** е нужно да започвате отначало класа за рационално число. Може да използвате вашето решение или файла `rational.cpp`.

### Домашно:

4. Направете предното упражнение и за класа `Complex`. Кои оператори имат смисъл в този контекст? Кои не?
