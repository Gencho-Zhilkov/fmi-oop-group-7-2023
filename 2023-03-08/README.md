# Упражнение 3


### [Тест](https://forms.gle/tiaAFLwqRMgLMro27)


### Жизнен цикъл на обектите

За примерите ще ползваме класа `Complex`, който дефинирахме предния път.
```cpp
class Complex {
private:
    double real;
    double imag;

public:
    ...
};
```

1. Създаване на нов обект (конструктори)

```cpp
Complex::Complex(const double real=0, const double imag=0) {
    this->real = real;
    this->imag = imag;
}
```

```cpp
Complex::Complex(const double real=0, const double imag=0):
    real(real), imag(imag) {}
```

```cpp
Complex::Complex(): real(0), imag(0) {}

Complex::Complex(const double real, const double imag):
    real(real), imag(imag) {}
```

_**Въпроси:**_
  - Какви са разликите между по-горните дефиниции?
  - Какво ще стане ако не дефинираме експлицитно конструктор(и) за класа `Complex::Complex`?


2. Създаване на _"копие"_ на вече съществуващ обект (_Copy_ конструктор):

```cpp
Complex::Complex(const Complex &that) {
    this->real = that.real;
    this->imag = that.imag;
}
```

```cpp
Complex::Complex(const Complex &that) {
    real = that.real;
    imag = that.imag;
}
```

```cpp
Complex::Complex(const Complex &that):
    real(that.real), imag(that.imag) {}
```

_**Въпроси:**_
  - Какви са разликите между по-горните дефиниции?
  - Какво ще се случи ако изпуснем амперсанда пред `that`?
  - Какво ще се случи ако не дефинираме експлицитен _copy_-конструктор?


3. Оператор за присвояване: присвояване на _**вече съществуващ**_ обект от даден клас!

```cpp
Complex& Complex::operator =(const Complex& that) {
    if (this != &that) {
        real = that.real;
        imag = that.imag;
    }
    return *this;
}
```

_**Въпроси:**_
  - За какво служи проверката `if (this != &that)` ?
  - Какво ще се случи ако не дефинираме експлицитен оператор за присвояване?


4. Унищожаване на обект (деструктор)

```cpp
Complex::~Complex() {
    // Какво трябва да се добави тук?
}
```

_**Въпроси:**_
  - Кога се вика деструктора?
  - Какво прави генерираният от компилатора деструктор?
  - Кога трябва да дефинираме експлицитен деструктор?
  - Можем ли да дефинираме повече от един деструктор за даден клас? _Защо?_
  - **[Бонус]**: Какво ще стане ако напишем `~Complex() = delete;`?


### Кратък тест: Кои методи ще се извикат във следните фрагмени код?

```cpp
Complex c1{2, 1};
Complex c2{c1};
```

```cpp
Complex c1{2, 1};
Complex c2 = c1;
```

```cpp
Complex c1{2, 1}, c2;
c2 = c1;
```


### Читанка:
  - [Teach Yourself Programming in Ten Years](https://norvig.com/21-days.html): есе със съвети за това как да станем _наистина_ добри в програмирането от [Питър Норвиг](https://norvig.com/), директор на _AI Reseacrh_ в _Google_ и съавтор на [_"Библията"_](https://aima.cs.berkeley.edu/) по изкуствен интелект. Има го преведено и на [български](http://www.math.bas.bg/bantchev/misc/teach-10-years.html).


### Задачи:

1. Часовник:

**Състояние**:
  - _v1_: Пазим три полета, съответно за час от денонощието и минута и секунда от настоящия час.
  - _v2_: Пазим само едно число, което съответства на броя секунди от началото на денонощието.

_**Въпрос**_: Какви предимства и недостатъци има всеки от двата подходи? Кой от тях предпочитате?

**Действия**: Имаме различни групи:

  а). _Конструктори_: искаме конструктор, който приема час, мин, и сек.

  б). _Колко е часа?_ или достъп до настоящото състояние на часовника (_getters_). Те са `const`, тъй като не променят състоянието.
  - `hour`, който връща часа.
  - `minutes`, който връща минутите.
  - `seconds`, който връща секундите.

  в). _Промяна на часа_:
  - `forward(hours, minutes, seconds)`, която мести часовника напред с `hours` часа, `minutes` минути и `secons` секунди.
  - `back(hours, minutes, seconds)`, която мести часовника назад с `hours` часа, `minutes` минути и `secons` секунди.

  г). _Работа с два часовника_:
  - `equals(Clock &then)`, който ни казва дали двата часовника показват едно и също време.
  - `compare(Clock &then)`, който връща $-1$, $0$ или $+1$ в зависимост от това _"сега"_ (`this`) e съответно преди, равно на, или след _"тогава"_ (`then`).
  - `until(Clock &then)`, който ни казва колко време има от _"сега"_ (`this`) до _"тогава"_ (`then`).

  д). _Отпечатване на конзолата_: Искаме да можем да отпечатаме едно и също време по различни начини, например `17:25:13` или `5:25:13 p.m.`. Как ще подходите към този проблем?


2. [Динамичен масив](https://en.wikipedia.org/wiki/Dynamic_array): целта на упражнението е да създадем масив с променлива дължина, която нараства _автоматично_, когато добавяме нови елементи в него (сходно с класа [`std::vector`](https://en.cppreference.com/w/cpp/container/vector)). За момента ще се ограничим до масив, които е само от цели числа (`int`). По нататък (когато говорим за _шаблони_ или _templates_), ще видим как можем да премахнем това ограничение!

За целта мплементирайте следните методи:
  - Конструктор по подразбиране, който създава празен масив.

  - Copy constructor и Assignment operator.
  _**Въпрос**_: Можете ли да използвате генерираните от компилатора?

  - Destructor, който освобождава динамичната памет!

  - `append(value)`, който добавя стойността `value` накрая на масива.

  - `insert(pos, value)`, който вмъква стойността `value` на позиция `pos`.
  _**Въпрос**_: Какво трябва да се случи ако `pos` е след _края_ на масива?

  - `pop()`, който премахва стойността, която е на последна позиция в масива.
  _**Въпрос**_: Какво трябва да се случи, когато масивът е празен?

  - `remove(pos)`, който премахва стойността, която се намира на позиция `pos`.
  _**Въпрос**_: Какво трябва да се случи ако `pos` е след _края_ на масива?

  - `clear()`, който премахва всички елементи от масива.

  - `isEmpty()`, който връща дали масивът е празен или съдържа елементи.

  - `size()`, който връща броя на елементите в масива.

  - `get(pos)`, който връща числото, което се намира на позиция `pos`.
  - `set(pos, value)`, който записва стойността `value` на позиция `pos`.
  - `find(value)`, който връща позицията на стойността `value`.

_**Въпроси**_:
  - Кои са _граничните случай_, които трябва да разгледате за последните три метода?
  - Кои методи трябва да бъдат `const`?
  - **[Бонус]**: сравнете нашата имплементация на динамичен масив, с тази на `std::vector`. Какви разлики откривате?

### Домашно:

Опитайте се да разделите кода на класа `IntVector` на хедър (`.hpp`) и клас (`.cpp`) файлове.
