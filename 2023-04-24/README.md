# Упражнение 9

## Шаблонни функции и класове (_Template functions and classes_):

### Мотивация

1. Искаме да напишем функция `max`, която приема два аргумента и връща по-големия от двата.

	_**Вариант 1**_ пишем по една функция за всеки възможен тип и да използваме _function overloading_ (претоварване на функции):
	```cpp
	int max(const int a, const int b) {
		return a >= b ? a : b;
	}

	long max(const long a, const long b) {
		return a >= b ? a : b;
	}

	float max(const float a, const float b) {
		return a >= b ? a : b;
	}

	double max(const double a, const double b) {
		return a >= b ? a : b;
	}

	// ...
	```

 	_**Въпрос**_: Какви са проблемите на този подход?

 	_**Вариант 2**_: използваме шаблонна функция (_template function_):
	```cpp
	template <typename T>
	const T& max(const T& a, const T& b) {
		return a >= b ? a : b;
	}
	```

 	_**Въпрос**_: Какво ще се случи ако извикаме функцията с аргументи от тип, за който не е дефиниран оператора `>=`, напр. комплексни числа?

2. Искаме да можем да дефинираме контейнери (колекции), чийто елементи да бъдат от произволен тип, напр. `std::vector`, `std::list`, `std::map`, `std::unordered_map`, ...


### Примери:

1. Функция `sum`, намираща сбора на елементите в даден масив:
	```cpp
	template <typename T>
	T sum(const T* const array, const size_t size) {
		T res{};

		for (size_t i = 0; i < size; i++) {
			res += array[i];
		}

		return res;
	}
	```

 	_**Въпрос**_: Можем ли да използваме за тип на резултата `const T&` вместо `Т` тук?


2. `Vector<T>`: подобно на класа `IntVector`, искаме да създадем масив с променлива, автоматично нарастваща дължина, но този път искаме елементите да могат да бъдат oт всякакъв тип, не само `int`!
	```cpp
	template <typename T>
	class Vector {
	private:
		size_t used;
		size_t capacity;
		T *array;

		// ...
	};
	```


### Специалиализация:

Понякога, често с оптимизационна цел, искаме да имаме специализирана имплементация на даден шаблон за определен тип/клас. Например, бихме могли да имплементираме `Vector<bool>` като масив от _битове_, вместо от булеви стойности (които заемат по един **байт** всяка) и по този начин да намалим значително необходимата памет.

```cpp
template <>
class Vector<bool> {
private:
	size_t used;
	size_t capacity;
	unsigned *bitset;

	// ...
};
```

<br/><img src="https://www.freeiconspng.com/thumbs/warning-icon-png/status-warning-icon-png-29.png" align="left" width="96px"/>  _**N.B.**_ НЕ бъркайте _шаблоните_ в С++ с _generics_ в _Java_ и _C#_! Въпреки че изглеждат _синтактично_ по един и същ начин и че често се използват за едни и същи неща (дефиниране на функция работеща с различни типове или на колекция/контейнер, който може да съдържа елементи от произволен тип), шаблоните и _generics_ са фундаментално различни и като _семантика_ (смисъл) и като _имплементация_! 

<br clear="left"/>

### Задачи:

1. Дефинирайте темплейтна функция swap, която разменя стойностите на две променливи от произволен тип.


2. Дефинирайте темплейтна функция, която приема масив от елементи от произволен тип и брой на елементите в масива и връща указател към най-малкия елемент в масива.


3. [**Единично свързан списък**](https://www.geeksforgeeks.org/data-structures/linked-list/singly-linked-list/):

	Единично свързанят списък е динамична структура от данни, която се състои от елементи, наречени "възли" или нодове (_nodes_). Всеки възел съдържа две части: данни и връзка - указател към следващия възел в списъка. Обикновено, връзката на последния възел сочи към `nullptr`, което указва края на списъка.

	<img src="https://media.geeksforgeeks.org/wp-content/uploads/20220816144425/LLdrawio.png"/>

	Ето примерен скелет на класовете за възел (`SNode`) и списък (`SList`):
	```cpp
	template <typename T>
	struct SNode {
		SNode<T> *next;
		T data;
	};

	template <typename T>
	class SList {
	private:
		SNode *head_;

		// ...
	};
	```

	Довършете класа за единично свързан списък като имплементирате
	следните методи:
	 - Канонично представяне и _move_ семантика
	 - `empty`: проверка дали списъкът е празен
	 - `insertFront`: който добавя елемент в началото на списъка
	 - `removeFront`: който премахва елемента в началото на списъка
	 - `head`: който връща първия елемент от списъка
	 - `tail`: който връща списък съдържащ (копия на) всички без първия елемент.

	_**Въпрос**_: Кои са, според вас, предимствата и недостатъците на свързания списък спрямо динамичнен масив като `Vector` или `std::vector` ?

4. _**Домашно**_: Имплементирайте класа `Vector<T>` от примера по-горе. За целта може да си помогнете с - или да преработите - имплементацията на класа `IntVector`.
