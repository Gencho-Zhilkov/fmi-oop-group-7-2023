#include <iostream>
#include <fstream>
#include <stdexcept>
#include <bitset>
#include <string>
#include <cassert>


// char ops
bool isDigit(const char c) {
	return c >= '0' && c <= '9';
}

int toDigit(const char c) {
	assert(isDigit(c));
	return c - '0';
}


class Sudoku {

private:
	int sudoku[9][9];

	// Check for duplicate values. Uses bitsets for efficiency.
	bool isValid() const {
		std::bitset<10> rows[9];
		std::bitset<10> cols[9];
		std::bitset<10> boxes[3][3];

		for (size_t i = 0; i < 9; i++) {
			for (size_t j = 0; j < 9; j++) {
				const int val = sudoku[i][j];
				assert(val >=0 && val <= 9);
				if (val == 0) { // Cell is empty
					continue;
				}

				// Check if we've already seen this value
				if (rows[i][val] || cols[j][val] || boxes[i/3][j/3][val]) {
					return false;
				}

				// If not, account it in the bit-sets
				rows[i].set(val);
				cols[j].set(val);
				boxes[i/3][j/3].set(val);
			}
		}

		return true;
	}

	// Check if we can use value `val` at position `row`, `col`
	bool canUse(const size_t row, const size_t col, const int val) const {
		// Check row `row` and column `col` for `val`
		for (size_t n = 0; n < 9; n++) {
			if (sudoku[row][n] == val || sudoku[n][col] == val) {
				return false;
			}
		}

		// Check the box
		const size_t boxI = 3 * (row / 3), boxJ = 3 * (col / 3);
		for (size_t i = 0; i < 3; i++) {
			for (size_t j = 0; j < 3; j++) {
				if (sudoku[boxI + i][boxJ + j] == val) {
					return false;
				}
			}
		}
		return true;
	}

	// Try finding a solution recursively starting from `cell`
	bool solve(const size_t cell) {
		assert (isValid());

		if (cell == 9 * 9) {
			// We've assigned a valid value to all cells: Sudoku is solved!
			return true;
		}

		const size_t i = cell / 9, j = cell % 9;
		const int val = sudoku[i][j];
		if (val != 0) {
			// Cell already has a value: Move on to next one...
			return solve(cell + 1);
		}

		// Empty cell: Try out assigning all possible values
		// and see if one leads to a valid solution.
		for (int v = 1; v <= 9; v++) {
			if (!canUse(i, j, v)) {
				continue;
			}

			sudoku[i][j] = v;
			if (solve(cell + 1)) {
				return true;
			}
		}

		// No valid solution exists, given the values before current cell
		sudoku[i][j] = 0;
		return false;
	}

	// Write a sudoku to an output stream (for ex. `std::cout`)
	// Declared as "friend" to be able to access the sudoku's private state!
	friend std::ostream& operator <<(std::ostream& os, const Sudoku& sudoku);

public:
	// Ctor: this gets called when a new `Sudoku` object is created
	// Fills sudoku from `line`. Empty cells are denoted by `.` or `0`.
	Sudoku(const std::string line) {
		if (line.length() != 9 * 9) {
			throw std::invalid_argument("Invalid input length!");
		}

		for (size_t i = 0; i < 9; i++) {
			for (size_t j = 0; j < 9; j++) {
				const char c = line[9 * i + j];
				if (c == '.') {
					sudoku[i][j] = 0;
				} else if (isDigit(c)) {
					sudoku[i][j] = toDigit(c);
				} else {
					throw std::invalid_argument("Invalid cell value!");
				}
			}
		}

		if (!isValid()) {
			throw std::invalid_argument("Invalid sudoku!");
		}
	}

	// Forbid copying and reassignment
	Sudoku(const Sudoku&) = delete;
	Sudoku& operator =(const Sudoku&) = delete;

	// Dtor: gets called when `Sudoku` object gets destroyed
	// Use default dtor generated by the compiler.
	~Sudoku() = default;

	// Try solving the sudoku.
	void solve() {
		bool solved = solve(0);
		if (!solved) {
			throw std::runtime_error("No solution found!");
		}
	}
};


// Pretty-print a sudoku on output stream `os`
std::ostream& operator <<(std::ostream& os, const Sudoku& sudoku) {
	for (size_t i = 0; i < 9; i++) {
		if (i == 3 || i == 6) {
			os << " ------+-------+------" << std::endl;
		}
		for (size_t j = 0; j < 9; j++) {
			if (j == 3 || j == 6) {
				os << " |";
			}
			const int val = sudoku.sudoku[i][j];
			const char c = val ? val + '0': '.';
			os << ' ' << c;
		}
		os << std::endl;
	}
	return os;
}


// You can find some puzzles at:   https://norvig.com/top95.txt
// Corresponding solutions are at: https://norvig.com/top95solutions.html
int main() {
	std::string line;
	std::cout << "> ";
	while (std::getline(std::cin, line)) {
		try {
			Sudoku sudoku(line);
			std::cout << sudoku << std::endl;
			sudoku.solve();
			std::cout << sudoku << std::endl;
		} catch (const std::exception& e) {
			std::cerr << e.what() << std::endl;
		}
		std::cout << "> ";
	}

	return 0;
}
