# Упражнение 13

### Емулация на _Енигма_:

<div align="center">
	<img src="https://th-thumbnailer.cdn-si-edu.com/i-UnSMSAeNPiw8sBjPAphUYSFr0=/1072x720/filters:no_upscale()/https://tf-cmsv2-smithsonianmag-media.s3.amazonaws.com/filer/f5/95/f59548db-c8c7-47a0-8404-9e44cd4b8db6/enigma.jpg" height="320px" />
</div>
<br/>

[Видео](https://youtu.be/ybkkiGtJmkM), обясненяващо различните компоненти на машината [_Енигма_](https://bg.wikipedia.org/wiki/%D0%95%D0%BD%D0%B8%D0%B3%D0%BC%D0%B0_(%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D0%B0)) и начина им на работа. Примерна емулация на _Енигма_: [тук](https://www.101computing.net/enigma-machine-emulator/) или [тук](https://piotte13.github.io/enigma-cipher/).


### Въпроси:

1. Кои са основните компоненти на _Енигма_?
2. По какво си приличат и по какво се различават те?
3. Кои са нещата, които ни интересуват и нещата, които можем да игнорираме, за да направим една емулация на _Енигма_?


### _Физически_ vs. _Логически_ модел на _Енигма_

<div align="center">
	<br/>
	<img src="https://hackaday.com/wp-content/uploads/2017/08/enigma.jpg" height="320px" />
	<p><strong>Физически модел</strong></p>
	<br/>
	<img src="https://vanhunteradams.com/Enigma/five.png" height="320px" />
	<p><strong>Логически модел</strong></p>
</div>
<br/>


### Задачи:

1. Дефинирайте абстрактен базов клас `Cypher`, съдържащ функция `encrypt`, която приема един символ и го _криптира_ до друг.

2. Цезаров шифър: дефинирайте класа `CeaserCypher`, които наследява `Cypher` и имплементира `encrypt` посредством отместване на всяка буква от азбуката с даден брой позиции (`offset`). Напр. ако отместването e 3, то тогава: 'A' -> 'D', 'B' -> 'E', ...

	_**Въпрос**_: Как декодираме символ, кодиран от Цезаров шифър с отместване `offset`?

3. Пермутационен шифър: дефинирайте класа `PermutationCypher`, които съдържа дадена пермутация на азбуката 'А' ... 'Z' и имплементира `encrypt` посредством съпоставянето на всяка буква от азбуката със съответсвтащата ѝ във въпросната пермутация.

4. Рефлектор: Можем да моделизираме рефлектора на _Енигма_ просто като един пермутационен шифър. На практика са съществували три модела рефлектори, съответсващи на следните пермутации:
	- **UKW-A**: EJMZALYXVBWFCRQUONTSPIKHGD
	- **UKW-B**: YRUHQSLDPXNGOKMIEBFZCWVJAT
	- **UKW-C**: FVPJIAOYEDRZXWGCTKUQSBNMHL

	Дефинирайте клас `Reflector`, който наследява `PermutationCypher`, и има конструктор, който приема името на един от трите възможни вида рефлектори и инициализира рефлектора със съответната пермутация.

5. Комутационен панел (_plugboard_): Можем да моделизираме комутационния панел също като пермутационен шифър, като за целта имаме следните правила:
	- Първоначално всяка буква отива в себе си: 'A' -> 'A', 'B' -> 'B', ... 'Z' -> 'Z'
	- Ако свържем дадени две букви, то всяка от тях отива в другата: A <-> D => 'A' -> 'D' и 'D' -> 'A'.
	- Можем да свържем дадена буква най-много веднъж.

	Дефинирайте клас `Plugboard`, който наследява `PermutationCypher` и имплементира функционалността на един комутационен панел. За целта добавете метод `connect`, който свързва дадени две букви.

6. Ротор (опростен вариант): Можем да моделираме един ротор като комбинация от следните три по-прости трансформации:
	- Цезаров шифър с отместване `offset`
	- Пермутационен шифър
	- Цезаров шифър с отместване `-offset`

	Пермутационният шифър тук може да бъде с една от слените пет пермутации, съответстващи на петте различни ротора, с които е разполагала всяка машина:
	- **I**: EKMFLGDQVZNTOWYHXUSPAIBRCJ
	- **II**: AJDKSIRUXBLHWTMCQGZNPYFVOE
	- **III**: BDFHJLCPRTXVZNYEIWGAKMUSQO
	- **IV**: ESOVPZJAYQUIRHXLNFTGKDCMWB
	- **V**: VZBRGITYUPSDNHLXAWMJQOFECK

	След криптирането на всеки символ, роторът се завърта с една позиция, т.е. `offset` се увеличава с 1.

	Дефинирайте клас `Rotor`, който да имплементира функционалността на един ротор. Използвайте вече написаните Цезаров и пермутационен шифри.


### Бонус/Домашно:

1. Последователност от ротори и емулация на _Енигма_: В реалната машина _Енигма_ имаме не един а три (понякога даже и четири) ротора. Освен това всеки от тях има и едно допълнително поле `notch`, което се използва за контролирането на ротацията на последващия ротор в редицата. Само първият ротор се отмества с по една позиция на всеки символ. За останалите важи следното правило: отместваме ротор `n+1` с една позиция напред тогава (и само тогава), когато отменстването на ротор `n` е равно на неговия `notch`. Преработете кода на класа `Rotor`, така че да вземе предвид това допълнително	усложнение.

	След това имплементирайте клас `Enigma`, който емулира машина _Енигма_ със следните компоненти: комутационен панел, три ротора и рефлектор. Криптирането на дадена буква става като тя първо премине през комутационния панел, след това през всеки от роторите, последвано от рефлектора, след което още веднъж през роторите, но в обратен ред и най-накрая още веднъж през комутационния панел.

	Може да откриете стойността на `notch` за всеки от отделните видове ротори ето [тук](https://www.cryptomuseum.com/crypto/enigma/wiring.htm#9).

2. Нормализация на входните данни: дефинирайте функция `normalize`, която према съобщение под формата на произволен символен низ (`std::string` или `char*`) и го _"нормализира"_, т.е. превръща във формат подходящ за вход на _Енигма_ машина, по следните правила:
	- Всички малки букви отиват в главни: 'a' -> 'A', 'b' -> 'B', ... 'z' -> 'Z'
	- Всички цифри се записват с букви: '0' -> 'ZERO', '1' -> 'ONE', ... '9' - 'NINE'
	- Всички останали символи се игнорират.

3. Тестова програма: напишете `main` функция, която прочита старова конфигурация на една енигма машина и съобщение за криптиране от клавиатурата, след което нормализира съобщението, криптира го и отпечатва резултата на `std::cout`.

	Може да тествате вашате имплементация като сравните изхода от вашата програма с този от някоя примерна емулация на _Енигма_.
