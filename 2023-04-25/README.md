# Упражнение 10

[Post-Mortem на Контролно 1](https://docs.google.com/presentation/d/15-1L03baplJkRRvdSSCIAUVYreK4Bv0iqkh7mic8Sq8/edit?usp=sharing)


## Полиморфизъм и Динамично свързване

_**Полиморфизмът**_ е способността да работим по един и същ начин (да използваме един и същ _интерфейс_) с обекти от различни типове.

_Полиморфизъмът_ може да бъде:

 - _статичен_: по време на компилацията. В С++ това се реализира с претоварване на функции (_function overloading_) или шаблони (_templates_)
 - _динамичен_: по време на изпълнението. В С++, както и в другите обектно ориентирани езици, това се реализира посредством _наследяване_ и _динамично свързване_.

_**Динамично свързване**_ (_dynamic dispatch_) е механизъм, който позволява на програмата да реши коя функция или метод да извика по време на изпълнението, вместо по време на компилацията на кода. Това се постига чрез използване на указатели към функции или виртуални функции. В комплект с наследяването, _динамичното свързване_ ни позволява да имплементираме _динамичен полиморфизъм_


### Мотивация:

Представете си, че създавате система за пресмятане на разходите на компания с различни видове служители:

1. Служители на трудов договор, които получават фиксирана заплата.
2. Контрактори на граждански договор, всеки от които има фиксирана часова ставка.
3. Констултанти по продажбите (_Sales_), които имат базова заплата плюс бонус пропорционален на броя продажби, който са направил

_**Въпроси**_:

1. Как бихте решили задачата без наследяване?
2. Какви са недостатъците на този подход?
3. Какво ще се случи ако искаме да добавим нов тип служител, например _мениджър_, който получава фиксирана заплата плюс процент от печалбата на компанията?
4. Помага ли да упростим решението наследяването **без** _динамичното свързване_ (виртуални функции) и ако да по какъв начин?
5. По какъв начин можем да използваме _динамичното свързване_, за да упростим решението на задачата? Какви предимства има според вас този подход? Какви недостатъци?


### Задача:

Имплементирайте решение на проблема, като използвате подходяща йерархия от класове и полиморфизъм (_виртуални_ функции).
